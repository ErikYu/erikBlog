
<!DOCTYPE html>
<html>
<head>
    <title>intro</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <style type="text/css">
        /* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
        /* Author: Nicolas Hery - http://nicolashery.com */
        /* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
        /* Source: https://github.com/nicolahery/markdownpad-github */

        /* RESET
        =============================================================================*/

        html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
            margin: 0;
            padding: 0;
            border: 0;
        }

        /* BODY
        =============================================================================*/

        body {
            font-family: Helvetica, arial, freesans, clean, sans-serif;
            font-size: 16px;
            line-height: 1.6;
            color: #333;
            background-color: #fff;
            padding: 20px;
            max-width: 960px;
            margin: 0 auto;
        }

        body>*:first-child {
            margin-top: 0 !important;
        }

        body>*:last-child {
            margin-bottom: 0 !important;
        }

        /* BLOCKS
        =============================================================================*/

        p, blockquote, ul, ol, dl, table, pre {
            margin: 15px 0;
        }

        /* HEADERS
        =============================================================================*/

        h1, h2, h3, h4, h5, h6 {
            margin: 20px 0 10px;
            padding: 0;
            font-weight: bold;
            -webkit-font-smoothing: antialiased;
        }

        h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
            font-size: inherit;
        }

        h1 {
            font-size: 28px;
            color: #000;
        }

        h2 {
            font-size: 24px;
            border-bottom: 1px solid #ccc;
            color: #000;
        }

        h3 {
            font-size: 18px;
        }

        h4 {
            font-size: 16px;
        }

        h5 {
            font-size: 14px;
        }

        h6 {
            color: #777;
            font-size: 14px;
        }

        body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
            margin-top: 0;
            padding-top: 0;
        }

        a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
            margin-top: 0;
            padding-top: 0;
        }

        h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
            margin-top: 10px;
        }

        /* LINKS
        =============================================================================*/

        a {
            color: #4183C4;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* LISTS
        =============================================================================*/

        ul, ol {
            padding-left: 30px;
        }

        ul li > :first-child,
        ol li > :first-child,
        ul li ul:first-of-type,
        ol li ol:first-of-type,
        ul li ol:first-of-type,
        ol li ul:first-of-type {
            margin-top: 0px;
        }

        ul ul, ul ol, ol ol, ol ul {
            margin-bottom: 0;
        }

        dl {
            padding: 0;
        }

        dl dt {
            font-size: 14px;
            font-weight: bold;
            font-style: italic;
            padding: 0;
            margin: 15px 0 5px;
        }

        dl dt:first-child {
            padding: 0;
        }

        dl dt>:first-child {
            margin-top: 0px;
        }

        dl dt>:last-child {
            margin-bottom: 0px;
        }

        dl dd {
            margin: 0 0 15px;
            padding: 0 15px;
        }

        dl dd>:first-child {
            margin-top: 0px;
        }

        dl dd>:last-child {
            margin-bottom: 0px;
        }

        /* CODE
        =============================================================================*/

        pre, code, tt {
            font-size: 12px;
            font-family: Consolas, "Liberation Mono", Courier, monospace;
        }

        code, tt {
            margin: 0 0px;
            padding: 0px 0px;
            white-space: nowrap;
            border: 1px solid #eaeaea;
            background-color: #f8f8f8;
            border-radius: 3px;
        }

        pre>code {
            margin: 0;
            padding: 0;
            white-space: pre;
            border: none;
            background: transparent;
        }

        pre {
            background-color: #f8f8f8;
            border: 1px solid #ccc;
            font-size: 13px;
            line-height: 19px;
            overflow: auto;
            padding: 6px 10px;
            border-radius: 3px;
        }

        pre code, pre tt {
            background-color: transparent;
            border: none;
        }

        kbd {
            -moz-border-bottom-colors: none;
            -moz-border-left-colors: none;
            -moz-border-right-colors: none;
            -moz-border-top-colors: none;
            background-color: #DDDDDD;
            background-image: linear-gradient(#F1F1F1, #DDDDDD);
            background-repeat: repeat-x;
            border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
            border-image: none;
            border-radius: 2px 2px 2px 2px;
            border-style: solid;
            border-width: 1px;
            font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
            line-height: 10px;
            padding: 1px 4px;
        }

        /* QUOTES
        =============================================================================*/

        blockquote {
            border-left: 4px solid #DDD;
            padding: 0 15px;
            color: #777;
        }

        blockquote>:first-child {
            margin-top: 0px;
        }

        blockquote>:last-child {
            margin-bottom: 0px;
        }

        /* HORIZONTAL RULES
        =============================================================================*/

        hr {
            clear: both;
            margin: 15px 0;
            height: 0px;
            overflow: hidden;
            border: none;
            background: transparent;
            border-bottom: 4px solid #ddd;
            padding: 0;
        }

        /* TABLES
        =============================================================================*/

        table th {
            font-weight: bold;
        }

        table th, table td {
            border: 1px solid #ccc;
            padding: 6px 13px;
        }

        table tr {
            border-top: 1px solid #ccc;
            background-color: #fff;
        }

        table tr:nth-child(2n) {
            background-color: #f8f8f8;
        }

        /* IMAGES
        =============================================================================*/

        img {
            max-width: 100%
        }
    </style>
    <style type="text/css">
        .highlight  { background: #ffffff; }
        .highlight .c { color: #999988; font-style: italic } /* Comment */
        .highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
        .highlight .k { font-weight: bold } /* Keyword */
        .highlight .o { font-weight: bold } /* Operator */
        .highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
        .highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
        .highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
        .highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
        .highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
        .highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
        .highlight .ge { font-style: italic } /* Generic.Emph */
        .highlight .gr { color: #aa0000 } /* Generic.Error */
        .highlight .gh { color: #999999 } /* Generic.Heading */
        .highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
        .highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
        .highlight .go { color: #888888 } /* Generic.Output */
        .highlight .gp { color: #555555 } /* Generic.Prompt */
        .highlight .gs { font-weight: bold } /* Generic.Strong */
        .highlight .gu { color: #aaaaaa } /* Generic.Subheading */
        .highlight .gt { color: #aa0000 } /* Generic.Traceback */
        .highlight .kc { font-weight: bold } /* Keyword.Constant */
        .highlight .kd { font-weight: bold } /* Keyword.Declaration */
        .highlight .kp { font-weight: bold } /* Keyword.Pseudo */
        .highlight .kr { font-weight: bold } /* Keyword.Reserved */
        .highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
        .highlight .m { color: #009999 } /* Literal.Number */
        .highlight .s { color: #d14 } /* Literal.String */
        .highlight .na { color: #008080 } /* Name.Attribute */
        .highlight .nb { color: #0086B3 } /* Name.Builtin */
        .highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
        .highlight .no { color: #008080 } /* Name.Constant */
        .highlight .ni { color: #800080 } /* Name.Entity */
        .highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
        .highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
        .highlight .nn { color: #555555 } /* Name.Namespace */
        .highlight .nt { color: #000080 } /* Name.Tag */
        .highlight .nv { color: #008080 } /* Name.Variable */
        .highlight .ow { font-weight: bold } /* Operator.Word */
        .highlight .w { color: #bbbbbb } /* Text.Whitespace */
        .highlight .mf { color: #009999 } /* Literal.Number.Float */
        .highlight .mh { color: #009999 } /* Literal.Number.Hex */
        .highlight .mi { color: #009999 } /* Literal.Number.Integer */
        .highlight .mo { color: #009999 } /* Literal.Number.Oct */
        .highlight .sb { color: #d14 } /* Literal.String.Backtick */
        .highlight .sc { color: #d14 } /* Literal.String.Char */
        .highlight .sd { color: #d14 } /* Literal.String.Doc */
        .highlight .s2 { color: #d14 } /* Literal.String.Double */
        .highlight .se { color: #d14 } /* Literal.String.Escape */
        .highlight .sh { color: #d14 } /* Literal.String.Heredoc */
        .highlight .si { color: #d14 } /* Literal.String.Interpol */
        .highlight .sx { color: #d14 } /* Literal.String.Other */
        .highlight .sr { color: #009926 } /* Literal.String.Regex */
        .highlight .s1 { color: #d14 } /* Literal.String.Single */
        .highlight .ss { color: #990073 } /* Literal.String.Symbol */
        .highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
        .highlight .vc { color: #008080 } /* Name.Variable.Class */
        .highlight .vg { color: #008080 } /* Name.Variable.Global */
        .highlight .vi { color: #008080 } /* Name.Variable.Instance */
        .highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
        .pl-c {
            color: #969896;
        }

        .pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
            color: #0086b3;
        }

        .pl-e,.pl-en {
            color: #795da3;
        }

        .pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
            color: #333;
        }

        .pl-ent {
            color: #63a35c;
        }

        .pl-k,.pl-s,.pl-st {
            color: #a71d5d;
        }

        .pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
            color: #df5000;
        }

        .pl-id {
            color: #b52a1d;
        }

        .pl-ii {
            background-color: #b52a1d;
            color: #f8f8f8;
        }

        .pl-sr .pl-cce {
            color: #63a35c;
            font-weight: bold;
        }

        .pl-ml {
            color: #693a17;
        }

        .pl-mh,.pl-mh .pl-en,.pl-ms {
            color: #1d3e81;
            font-weight: bold;
        }

        .pl-mq {
            color: #008080;
        }

        .pl-mi {
            color: #333;
            font-style: italic;
        }

        .pl-mb {
            color: #333;
            font-weight: bold;
        }

        .pl-md,.pl-mdhf {
            background-color: #ffecec;
            color: #bd2c00;
        }

        .pl-mdht,.pl-mi1 {
            background-color: #eaffea;
            color: #55a532;
        }

        .pl-mdr {
            color: #795da3;
            font-weight: bold;
        }

        .pl-mo {
            color: #1d3e81;
        }
        .task-list {
            padding-left:10px;
            margin-bottom:0;
        }

        .task-list li {
            margin-left: 20px;
        }

        .task-list-item {
            list-style-type:none;
            padding-left:10px;
        }

        .task-list-item label {
            font-weight:400;
        }

        .task-list-item.enabled label {
            cursor:pointer;
        }

        .task-list-item+.task-list-item {
            margin-top:3px;
        }

        .task-list-item-checkbox {
            display:inline-block;
            margin-left:-20px;
            margin-right:3px;
            vertical-align:1px;
        }
    </style>
</head>
<body>
<h1>Javascript面向对象编程综述</h1>
<p>面向对象的语言有一个标志，即拥有类的概念，抽象实例对象的公共属性与方法，基于类可以创建任意多个实例对象，一般具有封装、继承、多态的特性！但JS中对象与纯面向对象语言中的对象是不同的，ECMA标准定义JS中对象：无序属性的集合，其属性可以包含基本值、对象或者函数。可以简单理解为JS的对象是一组无序的值，其中的属性或方法都有一个名字，根据这个名字可以访问相映射的值（值可以是基本值/对象/方法）。</p>
<h3>一、理解对象:</h3>
<h5>第一种：基于Object对象</h5>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> person <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Object</span>();
<span class="pl-smi">person</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>My Name<span class="pl-pds">'</span></span>;
<span class="pl-smi">person</span>.<span class="pl-smi">age</span> <span class="pl-k">=</span> <span class="pl-c1">18</span>;
<span class="pl-smi">person</span>.<span class="pl-en">getName</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-k">return</span> <span class="pl-c1">this</span>.<span class="pl-c1">name</span>;
}</pre></div>
<h5>第二种：对象字面量方式（比较清楚的查找对象包含的属性及方法）</h5>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> person <span class="pl-k">=</span> {
    name <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>My name<span class="pl-pds">'</span></span>,
    age <span class="pl-k">:</span> <span class="pl-c1">18</span>,
    <span class="pl-en">getName</span> <span class="pl-k">:</span> <span class="pl-k">function</span>(){
        <span class="pl-k">return</span> <span class="pl-c1">this</span>.<span class="pl-c1">name</span>;
    }
}</pre></div>
<p>JS的对象可以使用‘.’操作符动态的扩展其属性，可以使用’delete’操作符或将属性值设置为’undefined’来删除属性。如下：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">person</span>.<span class="pl-smi">newAtt</span><span class="pl-k">=</span>’<span class="pl-k">new</span> <span class="pl-en">Attr</span>’;<span class="pl-c"><span class="pl-c">//</span>添加属性</span>
<span class="pl-en">alert</span>(<span class="pl-smi">person</span>.<span class="pl-smi">newAtt</span>);<span class="pl-c"><span class="pl-c">//</span>new Attr</span>
<span class="pl-k">delete</span> <span class="pl-smi">person</span>.<span class="pl-smi">age</span>;
<span class="pl-en">alert</span>(<span class="pl-smi">person</span>.<span class="pl-smi">age</span>);<span class="pl-c"><span class="pl-c">//</span>undefined(删除属性后值为undefined);</span></pre></div>
<h3>二、对象属性类型</h3>
<p>ECMA-262第5版定义了JS对象属性中特征（用于JS引擎，外部无法直接访问）。ECMAScript中有两种属性：数据属性和访问器属性</p>
<h5>1、数据属性：</h5>
<p>数据属性指包含一个数据值的位置，可在该位置读取或写入值，该属性有4个供述其行为的特性：<br>
    [[configurable]]:表示能否使用delete操作符删除从而重新定义，或能否修改为访问器属性。默认为true;<br>
    [[Enumberable]]:表示是否可通过for-in循环返回属性。默认true;<br>
    [[Writable]]:表示是否可修改属性的值。默认true;<br>
    [[Value]]:包含该属性的数据值。读取/写入都是该值。默认为undefined;如上面实例对象person中定义了name属性，其值为’My name’,对该值的修改都反正在这个位置<br>
    要修改对象属性的默认特征（默认都为true)，可调用Object.defineProperty()方法，它接收三个参数：属性所在对象，属性名和一个描述符对象（必须是：configurable、enumberable、writable和value，可设置一个或多个值）。<br>
    如下：（浏览器支持：IE9+、Firefox 4+、Chrome、Safari5+）</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> person <span class="pl-k">=</span> {};
<span class="pl-c1">Object</span>.<span class="pl-en">defineProperty</span>(person, <span class="pl-s"><span class="pl-pds">'</span>name<span class="pl-pds">'</span></span>, {
    configurable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
    writable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
    value<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jack<span class="pl-pds">'</span></span>
});
<span class="pl-en">alert</span>(<span class="pl-smi">person</span>.<span class="pl-c1">name</span>);<span class="pl-c"><span class="pl-c">//</span>Jack</span>
<span class="pl-k">delete</span> <span class="pl-smi">person</span>.<span class="pl-c1">name</span>;
<span class="pl-smi">person</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>lily<span class="pl-pds">'</span></span>;
<span class="pl-en">alert</span>(<span class="pl-smi">person</span>.<span class="pl-c1">name</span>);<span class="pl-c"><span class="pl-c">//</span>Jack</span></pre></div>
<p>可以看出，delete及重置person.name的值都没有生效，这就是因为调用defineProperty函数修改了对象属性的特征；值得注意的是一旦将configurable设置为false，则无法再使用defineProperty将其修改为true（执行会报错：can't redefine non-configurable property）;</p>
<h5>2、访问器属性：</h5>
<p>它主要包括一对getter和setter函数，在读取访问器属性时，会调用getter返回有效值；写入访问器属性时，调用setter，写入新值；该属性有以下4个特征：<br>
    [[Configurable]]:是否可通过delete操作符删除重新定义属性；<br>
    [[Numberable]]:是否可通过for-in循环查找该属性；<br>
    [[Get]]:读取属性时调用，默认：undefined;<br>
    [[Set]]:写入属性时调用，默认：undefined;<br>
    访问器属性不能直接定义，必须使用defineProperty()来定义，如下：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> person <span class="pl-k">=</span> {
    _age<span class="pl-k">:</span> <span class="pl-c1">18</span>
};
<span class="pl-c1">Object</span>.<span class="pl-en">defineProperty</span>(person, <span class="pl-s"><span class="pl-pds">'</span>isAdult<span class="pl-pds">'</span></span>, {
    <span class="pl-en">get</span><span class="pl-k">:</span> <span class="pl-k">function</span> () {
        <span class="pl-k">if</span> (<span class="pl-c1">this</span>.<span class="pl-smi">_age</span> <span class="pl-k">&gt;=</span> <span class="pl-c1">18</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        } <span class="pl-k">else</span> {
            <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
    }
});
<span class="pl-en">alert</span>(<span class="pl-smi">person</span>.<span class="pl-smi">isAdult</span><span class="pl-k">?</span><span class="pl-s"><span class="pl-pds">'</span>成年<span class="pl-pds">'</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">'</span>未成年<span class="pl-pds">'</span></span>);<span class="pl-c"><span class="pl-c">//</span>成年</span></pre></div>
<p>从上面可知，定义访问器属性时getter与setter函数不是必须的,并且，在定义getter与setter时不能指定属性的configurable及writable特性；<br>
    此外，ECMA-262（5）还提供了一个Object.defineProperties()方法，可以用来一次性定义多个属性的特性：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> person <span class="pl-k">=</span> {};
<span class="pl-c1">Object</span>.<span class="pl-en">defineProperties</span>(person,{
    _age<span class="pl-k">:</span>{
        value<span class="pl-k">:</span><span class="pl-c1">19</span>
    },
    isAdult<span class="pl-k">:</span>{
        <span class="pl-en">get</span><span class="pl-k">:</span> <span class="pl-k">function</span> () {
            <span class="pl-k">if</span> (<span class="pl-c1">this</span>.<span class="pl-smi">_age</span> <span class="pl-k">&gt;=</span> <span class="pl-c1">18</span>) {
                <span class="pl-k">return</span> <span class="pl-c1">true</span>;
            } <span class="pl-k">else</span> {
                <span class="pl-k">return</span> <span class="pl-c1">false</span>;
            }
        }
    }
});
<span class="pl-en">alert</span>(<span class="pl-smi">person</span>.<span class="pl-smi">isAdult</span><span class="pl-k">?</span><span class="pl-s"><span class="pl-pds">'</span>成年<span class="pl-pds">'</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">'</span>未成年<span class="pl-pds">'</span></span>);<span class="pl-c"><span class="pl-c">//</span>成年</span></pre></div>
<p>上述代码使用Object.defineProperties()方法同时定义了_age及isAudlt两个属性的特性<br>
    此外，使用Object.getOwnPropertyDescriptor()方法可以取得给定属性的特性：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> descriptor <span class="pl-k">=</span> <span class="pl-c1">Object</span>.<span class="pl-en">getOwnPropertyDescriptor</span>(person,<span class="pl-s"><span class="pl-pds">'</span>_age<span class="pl-pds">'</span></span>);
<span class="pl-en">alert</span>(<span class="pl-smi">descriptor</span>.<span class="pl-c1">value</span>);<span class="pl-c"><span class="pl-c">//</span>19</span></pre></div>
<p>对于数据属性，可以取得：configurable,enumberable,writable和value；<br>
    对于访问器属性，可以取得：configurable,enumberable,get和set</p>
<h3>三、创建对象</h3>
<p>使用Object构造函数或对象字面量都可以创建对象，但缺点是创建多个对象时，会产生大量的重复代码，因此下面介绍可解决这个问题的创建对象的方法</p>
<h5>1、工厂模式</h5>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">createPerson</span>(<span class="pl-smi">name</span>, <span class="pl-smi">age</span>, <span class="pl-smi">job</span>) {
    <span class="pl-k">var</span> o <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Object</span>();
    <span class="pl-smi">o</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> name;
    <span class="pl-smi">o</span>.<span class="pl-smi">age</span> <span class="pl-k">=</span> age;
    <span class="pl-smi">o</span>.<span class="pl-smi">job</span> <span class="pl-k">=</span> job;
    <span class="pl-smi">o</span>.<span class="pl-en">getName</span> <span class="pl-k">=</span> <span class="pl-k">function</span> () {
        <span class="pl-k">return</span> <span class="pl-c1">this</span>.<span class="pl-c1">name</span>;
    }
    <span class="pl-k">return</span> o;<span class="pl-c"><span class="pl-c">//</span>使用return返回生成的对象实例</span>
}
<span class="pl-k">var</span> person <span class="pl-k">=</span> <span class="pl-en">createPerson</span>(<span class="pl-s"><span class="pl-pds">'</span>Jack<span class="pl-pds">'</span></span>, <span class="pl-c1">19</span>, <span class="pl-s"><span class="pl-pds">'</span>SoftWare Engineer<span class="pl-pds">'</span></span>);</pre></div>
<p>创建对象交给一个工厂方法来实现，可以传递参数，但主要缺点是无法识别对象类型，因为创建对象都是使用Object的原生构造函数来完成的。</p>
<h5>2、构造函数模式</h5>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Person</span>(<span class="pl-smi">name</span>,<span class="pl-smi">age</span>,<span class="pl-smi">job</span>){
    <span class="pl-c1">this</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> name;
    <span class="pl-c1">this</span>.<span class="pl-smi">age</span> <span class="pl-k">=</span> age;
    <span class="pl-c1">this</span>.<span class="pl-smi">job</span> <span class="pl-k">=</span> job;
    <span class="pl-c1">this</span>.<span class="pl-en">getName</span> <span class="pl-k">=</span> <span class="pl-k">function</span> () {
        <span class="pl-k">return</span> <span class="pl-c1">this</span>.<span class="pl-c1">name</span>;
    }
}
<span class="pl-k">var</span> person1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Person</span>(<span class="pl-s"><span class="pl-pds">'</span>Jack<span class="pl-pds">'</span></span>, <span class="pl-c1">19</span>, <span class="pl-s"><span class="pl-pds">'</span>SoftWare Engineer<span class="pl-pds">'</span></span>);
<span class="pl-k">var</span> person2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Person</span>(<span class="pl-s"><span class="pl-pds">'</span>Liye<span class="pl-pds">'</span></span>, <span class="pl-c1">23</span>, <span class="pl-s"><span class="pl-pds">'</span>Mechanical Engineer<span class="pl-pds">'</span></span>);</pre></div>
<p>使用自定义的构造函数（与普通函数一样，只是用它来创建对象），定义对象类型（如：Person）的属性和方法。它与工厂方法区别在于：<br>
    没有显式地创建对象<br>
    直接将属性和方法赋值给this对象；<br>
    没有return语句；</p>
<p>此外，要创建Person的实例，必须使用new关键字，以Person函数为构造函数，传递参数完成对象创建；实际创建经过以下4个过程：<br>
    创建一个对象<br>
    将函数的作用域赋给新对象（因此this指向这个新对象，如：person1）<br>
    执行构造函数的代码<br>
    返回该对象<br>
    上述由Person构造函数生成的两个对象person1与person2都是Person的实例，因此可以使用instanceof判断，并且因为所有对象都继承Object，因此person1 instanceof Object也返回真：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-en">alert</span>(person1 <span class="pl-k">instanceof</span> Person);<span class="pl-c"><span class="pl-c">//</span>true;</span>
<span class="pl-en">alert</span>(person2 <span class="pl-k">instanceof</span> Person);<span class="pl-c"><span class="pl-c">//</span>true;</span>
<span class="pl-en">alert</span>(person1 <span class="pl-k">instanceof</span> <span class="pl-c1">Object</span>);<span class="pl-c"><span class="pl-c">//</span>true;</span>
<span class="pl-en">alert</span>(<span class="pl-smi">person1</span>.<span class="pl-c1">constructor</span> <span class="pl-k">===</span> <span class="pl-smi">person2</span>.<span class="pl-c1">constructor</span>);<span class="pl-c"><span class="pl-c">//</span>ture;</span></pre></div>
<p>虽然构造函数方式比较不错，但也存在缺点，那就是在创建对象时，特别针对对象的属性指向函数时，会重复的创建函数实例，以上述代码为基础，可以改写为：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Person</span>(<span class="pl-smi">name</span>,<span class="pl-smi">age</span>,<span class="pl-smi">job</span>){
    <span class="pl-c1">this</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> name;
    <span class="pl-c1">this</span>.<span class="pl-smi">age</span> <span class="pl-k">=</span> age;
    <span class="pl-c1">this</span>.<span class="pl-smi">job</span> <span class="pl-k">=</span> job;
    <span class="pl-c1">this</span>.<span class="pl-smi">getName</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Function</span> () {<span class="pl-c"><span class="pl-c">//</span>改写后效果与原代码相同，不过是为了方便理解</span>
        <span class="pl-k">return</span> <span class="pl-c1">this</span>.<span class="pl-c1">name</span>;
    }
}</pre></div>
<p>上述代码，创建多个实例时，会重复调用new Function();创建多个函数实例，这些函数实例还不是一个作用域中，当然这一般不会有错，但这会造成内存浪费。当然，可以在函数中定义一个getName = getName的引用，而getName函数在Person外定义，这样可以解决重复创建函数实例问题，但在效果上并没有起到封装的效果，如下所示：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Person</span>(<span class="pl-smi">name</span>,<span class="pl-smi">age</span>,<span class="pl-smi">job</span>){
    <span class="pl-c1">this</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> name;
    <span class="pl-c1">this</span>.<span class="pl-smi">age</span> <span class="pl-k">=</span> age;
    <span class="pl-c1">this</span>.<span class="pl-smi">job</span> <span class="pl-k">=</span> job;
    <span class="pl-c1">this</span>.<span class="pl-smi">getName</span> <span class="pl-k">=</span> getName;
}
<span class="pl-k">function</span> <span class="pl-en">getName</span>() {<span class="pl-c"><span class="pl-c">//</span>到处是代码，看着乱！！</span>
        <span class="pl-k">return</span> <span class="pl-c1">this</span>.<span class="pl-c1">name</span>;
}</pre></div>
<h5>3、原型模式</h5>
<p>JS每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，它是所有通过new操作符使用函数创建的实例的原型对象。原型对象最大特点是，所有对象实例共享它所包含的属性和方法，也就是说，所有在原型对象中创建的属性或方法都直接被所有对象实例共享。</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Person</span>(){
}
<span class="pl-smi">Person</span>.<span class="pl-c1">prototype</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>Jack<span class="pl-pds">'</span></span>;<span class="pl-c"><span class="pl-c">//</span>使用原型来添加属性</span>
<span class="pl-smi">Person</span>.<span class="pl-c1">prototype</span>.<span class="pl-smi">age</span> <span class="pl-k">=</span> <span class="pl-c1">29</span>;
<span class="pl-smi">Person</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">getName</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-k">return</span> <span class="pl-c1">this</span>.<span class="pl-c1">name</span>;
}
<span class="pl-k">var</span> person1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Person</span>();
<span class="pl-en">alert</span>(<span class="pl-smi">person1</span>.<span class="pl-en">getName</span>());<span class="pl-c"><span class="pl-c">//</span>Jack</span>
<span class="pl-k">var</span> person2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Person</span>();
<span class="pl-en">alert</span>(<span class="pl-smi">person1</span>.<span class="pl-smi">getName</span> <span class="pl-k">===</span> <span class="pl-smi">person2</span>.<span class="pl-smi">getName</span>);<span class="pl-c"><span class="pl-c">//</span>true;共享一个原型对象的方法</span></pre></div>
<p>原型是指向原型对象的，这个原型对象与构造函数没有太大关系，唯一的关系是函数的prototype是指向这个原型对象！而基于构造函数创建的对象实例也包含一个内部指针为：[[prototype]]指向原型对象。<br>
    实例属性或方法的访问过程是一次搜索过程：<br>
    首先从对象实例本身开始，如果找到属性就直接返回该属性值；<br>
    如果实例本身不存在要查找属性，就继续搜索指针指向的原型对象，在其中查找给定名字的属性，如果有就返回；<br>
    基于以上分析，原型模式创建的对象实例，其属性是共享原型对象的；但也可以自己实例中再进行定义，在查找时，就不从原型对象获取，而是根据搜索原则，得到本实例的返回；简单来说，就是实例中属性会屏蔽原型对象中的属性；</p>
<p>原型与in操作符<br>
    一句话：无论原型中属性，还是对象实例的属性，都可以使用in操作符访问到；要想判断是否是实例本身的属性可以使用object.hasOwnProperty(‘attr’)来判断；</p>
<p>原生对象中原型<br>
    原生对象中原型与普通对象的原型一样，可以添加/修改属性或方法，如以下代码为所有字符串对象添加去左右空白原型方法：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-c1">String</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">trim</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-k">return</span> <span class="pl-c1">this</span>.<span class="pl-c1">replace</span>(<span class="pl-sr"><span class="pl-pds">/</span><span class="pl-k">^</span><span class="pl-c1">\s</span><span class="pl-k">+</span><span class="pl-pds">/</span></span>,<span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>).<span class="pl-c1">replace</span>(<span class="pl-sr"><span class="pl-pds">/</span><span class="pl-c1">\s</span><span class="pl-k">+</span><span class="pl-k">$</span><span class="pl-pds">/</span></span>,<span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>);
}
<span class="pl-k">var</span> str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>   word space   <span class="pl-pds">'</span></span>;
<span class="pl-en">alert</span>(<span class="pl-s"><span class="pl-pds">'</span>!<span class="pl-pds">'</span></span><span class="pl-k">+</span><span class="pl-smi">str</span>.<span class="pl-en">trim</span>()<span class="pl-k">+</span><span class="pl-s"><span class="pl-pds">'</span>!<span class="pl-pds">'</span></span>);<span class="pl-c"><span class="pl-c">//</span>!word space!</span></pre></div>
<p>原型模式的缺点，它省略了为构造函数传递初始化参数，这在一定程序带来不便；另外，最主要是当对象的属性是引用类型时，它的值是不变的，总是引用同一个外部对象，所有实例对该对象的操作都会其它实例：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Person</span>() {
}
<span class="pl-smi">Person</span>.<span class="pl-c1">prototype</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>Jack<span class="pl-pds">'</span></span>;
<span class="pl-smi">Person</span>.<span class="pl-c1">prototype</span>.<span class="pl-smi">lessons</span> <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">'</span>Math<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>Physics<span class="pl-pds">'</span></span>];
<span class="pl-k">var</span> person1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Person</span>();
<span class="pl-smi">person1</span>.<span class="pl-smi">lessons</span>.<span class="pl-c1">push</span>(<span class="pl-s"><span class="pl-pds">'</span>Biology<span class="pl-pds">'</span></span>);
<span class="pl-k">var</span> person2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Person</span>();
<span class="pl-en">alert</span>(<span class="pl-smi">person2</span>.<span class="pl-smi">lessons</span>);<span class="pl-c"><span class="pl-c">//</span>Math,Physics,Biology，person1修改影响了person2</span></pre></div>
<h5>4、组合构造函数及原型模式</h5>
<p>目前最为常用的定义类型方式，是组合构造函数模式与原型模式。构造函数模式用于定义实例的属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方方法的引用，最大限度的节约内存。此外，组合模式还支持向构造函数传递参数，可谓是集两家之所长。</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Person</span>(<span class="pl-smi">name</span>, <span class="pl-smi">age</span>, <span class="pl-smi">job</span>) {
    <span class="pl-c1">this</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> name;
    <span class="pl-c1">this</span>.<span class="pl-smi">age</span> <span class="pl-k">=</span> age;
    <span class="pl-c1">this</span>.<span class="pl-smi">job</span> <span class="pl-k">=</span> job;
    <span class="pl-c1">this</span>.<span class="pl-smi">lessons</span> <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">'</span>Math<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>Physics<span class="pl-pds">'</span></span>];
}
<span class="pl-smi">Person</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> {
    <span class="pl-en">constructor</span>: Person,<span class="pl-c"><span class="pl-c">//</span>原型字面量方式会将对象的constructor变为Object，此外强制指回Person</span>
    getName: <span class="pl-k">function</span> () {
        <span class="pl-k">return</span> <span class="pl-c1">this</span>.<span class="pl-c1">name</span>;
    }
}
<span class="pl-k">var</span> person1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Person</span>(<span class="pl-s"><span class="pl-pds">'</span>Jack<span class="pl-pds">'</span></span>, <span class="pl-c1">19</span>, <span class="pl-s"><span class="pl-pds">'</span>SoftWare Engneer<span class="pl-pds">'</span></span>);
<span class="pl-smi">person1</span>.<span class="pl-smi">lessons</span>.<span class="pl-c1">push</span>(<span class="pl-s"><span class="pl-pds">'</span>Biology<span class="pl-pds">'</span></span>);
<span class="pl-k">var</span> person2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Person</span>(<span class="pl-s"><span class="pl-pds">'</span>Lily<span class="pl-pds">'</span></span>, <span class="pl-c1">39</span>, <span class="pl-s"><span class="pl-pds">'</span>Mechanical Engneer<span class="pl-pds">'</span></span>);
<span class="pl-en">alert</span>(<span class="pl-smi">person1</span>.<span class="pl-smi">lessons</span>);<span class="pl-c"><span class="pl-c">//</span>Math,Physics,Biology</span>
<span class="pl-en">alert</span>(<span class="pl-smi">person2</span>.<span class="pl-smi">lessons</span>);<span class="pl-c"><span class="pl-c">//</span>Math,Physics</span>
<span class="pl-en">alert</span>(<span class="pl-smi">person1</span>.<span class="pl-smi">getName</span> <span class="pl-k">===</span> <span class="pl-smi">person2</span>.<span class="pl-smi">getName</span>);<span class="pl-c"><span class="pl-c">//</span>true,//共享原型中定义方法</span></pre></div>
<p>在所接触的JS库中，jQuery类型的封装就是使用组合模式来实例的！！！</p>
<h5>5、动态原型模式</h5>
<p>组合模式中实例属性与共享方法（由原型定义）是分离的，这与纯面向对象语言不太一致；动态原型模式将所有构造信息都封装在构造函数中，又保持了组合的优点。其原理就是通过判断构造函数的原型中是否已经定义了共享的方法或属性，如果没有则定义，否则不再执行定义过程。该方式只原型上方法或属性只定义一次，且将所有构造过程都封装在构造函数中，对原型所做的修改能立即体现所有实例中：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Person</span>(<span class="pl-smi">name</span>, <span class="pl-smi">age</span>, <span class="pl-smi">job</span>) {
    <span class="pl-c1">this</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> name;
    <span class="pl-c1">this</span>.<span class="pl-smi">age</span> <span class="pl-k">=</span> age;
    <span class="pl-c1">this</span>.<span class="pl-smi">job</span> <span class="pl-k">=</span> job;
    <span class="pl-c1">this</span>.<span class="pl-smi">lessons</span> <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">'</span>Math<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>Physics<span class="pl-pds">'</span></span>];
}
<span class="pl-k">if</span> (<span class="pl-k">typeof</span> <span class="pl-c1">this</span>.<span class="pl-smi">getName</span> <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">'</span>function<span class="pl-pds">'</span></span>) {<span class="pl-c"><span class="pl-c">//</span>通过判断实例封装</span>
　　<span class="pl-smi">Person</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> {
　　　　<span class="pl-en">constructor</span>: Person,<span class="pl-c"><span class="pl-c">//</span>原型字面量方式会将对象的constructor变为Object，此外强制指回Person</span>
　　　　getName: <span class="pl-k">function</span> () {
　　　　　　<span class="pl-k">return</span> <span class="pl-c1">this</span>.<span class="pl-c1">name</span>;
　　　　}
　　}
}
<span class="pl-k">var</span> person1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Person</span>(<span class="pl-s"><span class="pl-pds">'</span>Jack<span class="pl-pds">'</span></span>, <span class="pl-c1">19</span>, <span class="pl-s"><span class="pl-pds">'</span>SoftWare Engneer<span class="pl-pds">'</span></span>);
<span class="pl-smi">person1</span>.<span class="pl-smi">lessons</span>.<span class="pl-c1">push</span>(<span class="pl-s"><span class="pl-pds">'</span>Biology<span class="pl-pds">'</span></span>);
<span class="pl-k">var</span> person2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Person</span>(<span class="pl-s"><span class="pl-pds">'</span>Lily<span class="pl-pds">'</span></span>, <span class="pl-c1">39</span>, <span class="pl-s"><span class="pl-pds">'</span>Mechanical Engneer<span class="pl-pds">'</span></span>);
<span class="pl-en">alert</span>(<span class="pl-smi">person1</span>.<span class="pl-smi">lessons</span>);<span class="pl-c"><span class="pl-c">//</span>Math,Physics,Biology</span>
<span class="pl-en">alert</span>(<span class="pl-smi">person2</span>.<span class="pl-smi">lessons</span>);<span class="pl-c"><span class="pl-c">//</span>Math,Physics</span>
<span class="pl-en">alert</span>(<span class="pl-smi">person1</span>.<span class="pl-smi">getName</span> <span class="pl-k">===</span> <span class="pl-smi">person2</span>.<span class="pl-smi">getName</span>);<span class="pl-c"><span class="pl-c">//</span>true,//共享原型中定义方法</span></pre></div>
</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
